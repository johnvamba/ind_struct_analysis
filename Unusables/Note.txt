TO DO LIST!

// Reformulate FEMCalculator correctly. < almost done

New TD
Steps.

0. initate variables
	group for supportLines
	group for linear graphs
		shearforce
		momentforce
		deflect
	path(2) for stresses
		bending stress
		shearstress

1. generate premembers graph. require number of members with lengths

	pregraph()
		if(collected obj !== stored obj || stored obj == empty)
			get:members with lengths
			stored:collected
		else
			return storedObj;

		clean pregraph;
		construct spaces between.. 
			new Line inbetween members
		return storedObj;

2. calculate === works on calc button.
	initGraph()
		if(pregraph != requirements)
		get: 





PaperClass.js (paperscope)
	pregraph()
	initgraph()

	sub actions to group
		intersection()
		onMoveDrag() = pan linear graph


Main.js (js scripts)
	addbutton -> pregraph() // establish graph
	calcbutton ->	pregraph() // reistablish graph
					initgraph() // init graph
	illustration -> show modal.





Graph Heirarchy

Items in view
	PathGroup
		Shear
		Moment
		Bend
	Beam
		Box
	Separators
		Lines
	Stresses(as rectangle)
		Bending
		Shear



List 1/21/2017

Add elements to maincontrol.js and BAN.htmlfile (DO IN 3HRS, or less)
	revised(required) sampleval object structure.
		follow datastruct.js synchronize funct or all list datastuct.
		supply data.
	form elements regarding use of sample data in sampleval.js.
		radio buttons for changeable sample list in sampleval.
	a simple save/load system for sample data.(optional)
		use variables(all) in femcalculator and datastruct.
		add saveload functions on femcalculator, add proper saveload mechanics on dataStruct.js

Revise UI/UX for illustrations	(DO IN 3HRS or less)
	test illustrations and display positions
		use css to pin information on designated area.
		complete list to add.
			radio button form for linear graph : for dynamics. Shear, Moment, Deflection
			add css boxedarea for crossectional details: ShearStress, BendingStress, possibly bottom of modal.

Regulate infomation ranges. (optional), just add limitations. (do in 2 hrs)


NOTE! : 1/22/2017

	SHEAR STRESS, BENDING STRESS REQUIRES DIMENSIONS




square: {
		area:,
		inertia: ,
		centriod: 
	},
	rec: {
		area: ,
		inertia: ,
		centriod: 
	},
	ibeam: {
		area:,
		inertia: ,
		centriod: 
	},
	tbeam: {
		area: ,
		inertia: ,
		centriod: 
	},
	circle:{
		area: ,
		inertia: ,
		centriod: 
	},
	basic:{
		area: {
		},
		inertia: {
		},
		centriod: {
		}
	}

Note: 
	var.method() is required in performing arithmetic,
	+var displays javascript number primitive
	var.toString() shows complete number in string


      if shortest


      low   high
range 1
length    1   10


planned
condition 1
  if low*10 > high && high/2 > low  return 0.05 increment

  low/high






function standardLength(lowest, min){ //incremental length for stresses.
  //ratio 5/100 or .05 a meter
  if min===null
  min=0.05; //global var?
  return lowest * min;
}
l3+ddeedbd0n3


To

Good day,

NOTE:

Part1:
I am applying for the position as tech support in your company.

I am captivated in the position as technical support sup


Values and Outlook

Challenger
Creative
Teamwork


Possible words

intinsict
devoted
A 

this.msc = function(){
    function findShortLength(){
      if(members.length <= 0){
        throw new Error('Empty Member List');
      }
      var min, thisObj, thisInd;
      $(members).each(function(ind, obj){
        if(obj.eil.lenInMeters < min || ind===0){
          min = obj.eil.lenInMeters;
          thisObj = obj;
          thisInd = ind;
        } 
      });
      min = parseInt(min.toFixed());
      return {
        min,
        thisObj,
        thisInd
      }
    }

    function inspectReactions(){ //revise please.
      
    }
    return {
      totalLength: this.getTotalLength() / 1000,
      shortestLength: findShortLength().min,
    }
  } //end of Msc

12.642857142857139, 8.142857142857139, 3.428571428571445, -2.7857142857142776, 29.92857142857141, 29.99999999999998, -9.999999999999993, 0
12.642857142857139, 8.142857142857139, 3.428571428571445, 2.7857142857142776, 29.92857142857141, -29.999999999999975, -9.999999999999993, 0
12.642857142857139, 8.142857142857139, 3.428571428571445, -2.7857142857142776, 29.92857142857141, 29.999999999999975, -9.999999999999993, -0
12.642857142857139, 8.142857142857139, 3.428571428571445, -2.7857142857142776, 29.92857142857141, 29.99999999999998, -9.999999999999993, -0 ]


window.onload = function() {
var canvas = document.getElementById('myCanvas');
  paper.setup(canvas);

  var PathGroup = function(allobj,splits){
    if(allobj === undefined || splits === undefined){
      console.log(allobj === undefined , splits === undefined);
      return;
    }
    console.log(allobj === undefined , splits === undefined);
    
    var intersectLine = new paper.Path({
      position: paper.view.center,
      segments:[[0,0],[0,paper.view.bounds.bottom]],
      strokeColor: 'black',
      strokeWidth:1,
      visible:true,
      opacity:1
    }),
    intersectText = new paper.PointText({
      content: '',
      pivot: [0,0],
      fillColor: 'black'
    });

    var path = ['shearPath', 'momentPath', 'deflectPath'];
    var pathColor = ['red','green','blue'];
    var others = ['shearStress', 'bendStress'];

    // var text = new Array();
    var paths = new paper.Group();
    var textforces = new paper.Group();

    //do here
    for (var i =0 ; i < path.length;i++){
      paths.addChild(
        // new paper.Path({ //original
        new paper.Path.Rectangle({
          size:[sampvals.width,150],
          // position: paper.view.center, //puts paths center to view center
          // point: paper.view.center, //puts top left corner to center.
          name: path[i],
          strokeColor: pathColor[i],
          fillColor: pathColor[i],
          // segments:[[0,0]],
          strokeWidth:2
        })
      );
      paths.children[i].fillColor.alpha = 0.2;

      textforces.addChild(new paper.Group({
        name:path[i],
        fillColor:pathColor[i]
        // pivot:[0,0]
      }));
    }
    console.log(paths);

    this.active;
    this.changePathActive = function(path){ //pathname
      for (var i = 0; i < paths.children.length; i++) {
        paths.children[i].visible = false;
        if (path === undefined || path === 'allPath'){
          paths.children[i].visible = true;
        } else if(paths.children[i].name === path){
          paths.children[i].visible = true;
          this.active = paths.children[i];
        }
      }
    }

    this.clear = function(){
      intersectLine.remove();
      intersectText.remove();
      this.paths.removeChildren();
    }
  }

  // new PathGroup;
  var MscGroup = function(allobj){ //objects beam
    if(allobj === undefined){
      return;
    }
    
    this.group = new paper.Group();
    this.supports = new paper.CompoundPath({
      strokeColor: 'black',
      opacity:.1
    });
    this.beam = new paper.Path.Rectangle({
      size: [sampvals.width,10],
      point: [0,-5],
      name:'Beam',
      fillColor: 'black',
      strokeColor: 'black',
      strokeWidth:1,
      // opacity:.1
    });

    this.clear = function(){
      this.group.removeChildren();
      this.beam.remove();
      this.supports.removeChildren();
    }
    //beam
    //supports
  }

  var mainGroup=new paper.Group();

  var Stresses = function(){
    this.show = function(){}
    this.hide = function(){}
    this.change = function(){}
  }

  mainGroup.on({
    mouseclick: function(event){
      console.log('click');
    },
    mousedrag: function(event){
      event.modifiers.d = paper.Key.isDown('d');
      console.log(this);
      if(event.modifiers.d){
        console.log('Should move');
        return;
      }
      //  console.log('click')
      console.log('drag');
    }
  });

  // steps;

  var samp,samp2;
  function steps(beamObj,splitObjs){ //put everything here
    //step 1

    samp = new PathGroup(beamObj,splitObjs);
    samp2 = new MscGroup(beamObj);
    
    console.log(paper.project);
    // mainGroup.removeChildren();
  }
  newglobal.showGraph = steps;

  // steps(12,123);
  
  function changePath(path){
    samp.changePathActive(path);
  }
  newglobal.changePath = changePath;

}



var sampvals = {
  width:200,
  beamLens: [3,5,3],
}

